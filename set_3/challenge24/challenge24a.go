package challenge24

import (
	cryptorand "crypto/rand"
	"cryptopals/set_3/mt19937"
	"encoding/binary"
	"fmt"
	mathrand "math/rand"
)

var knownText = []byte("AAAAAAAAAAAAAA")

func challenge24a() {

	// 0. Define PRNG settings
	seed := mathrand.Intn(65536)
	fmt.Println(">>Shhhh, seed is", seed)

	// 2. Craft input. Input is: random preppend + known text
	randomPrep := make([]byte, mathrand.Intn(50))
	cryptorand.Read(randomPrep)

	input := append(randomPrep, knownText...)

	// 3. Encrypt
	encrypted := MTCipher(seed, input)

	// 4. Recover the underlaying keystream corresponding to our known plaintext injection sequence. We'll start from its first index in the encryption.
	// E.g, X is our injected plaintext
	// AAAA AAAA AAAX XXXX start = 11
	// AAAAA AAAAA AAAXX XXXXX start = 13
	start := len(encrypted) - len(knownText)

	knownKeystream := make([]byte, len(knownText))

	for n := range knownKeystream {
		knownKeystream[n] = encrypted[start+n] ^ byte('A')
	}

	// 5. Bruteforce the seed with all the seed space of 16 bits

	// 5.1 Calculate offsets to match new PRNG bytes with knownKeystream corresponding bytes. We need the number of generations to skip (toSkip)
	// and the first byte we'll use from the first random number (ind).
	// PRECAUTION: remember that gen.Rand() returns a whole uint32 and we've been encrypting with single bytes. There's 4 per uint32,
	// so we can think of the encryption as blocks of 4, each representing a randomly generated uint32.
	// E.g
	// AAAA AAAA AAAA AXXX XXXX toSkip = 3 , ind = 1
	// here our target (first X) would land in block 4, so first 3 generated numbers should be thrown away.
	// We would skip 3 and start in the 4th number at its byte index ind.
	toSkip := start / 4
	ind := start % 4

	// 5.2 Try each number of the seed space, which is 16 bits
	for x := range 65536 {
		// 5.3 Instantiate new PRNG and skip its first toSkip numbers so that when called again will yield
		// the number matching the first random number of our studied sequence
		gen := mt19937.NewPRNG(x)
		for range toSkip {
			gen.Rand()
		}

		// 5.4 Instead of working with uint32's, we'll use the generator to populate this bytes buffer, keystreamBytes, and update as needed inside 5.5.
		// This way we'll directly work with a random bytes generator, which will be easier since we're studying bytes.
		keystreamBytes := make([]byte, 4)
		binary.BigEndian.PutUint32(keystreamBytes, gen.Rand())

		// 5.5 Loop the entire knownKeystream bytes to validate this seed bruteforcing. We'll compare [known byte] vs [this seed's corresponding byte].
		// If there's a different byte in the sequence, discard seed.
		loopInd := ind // generate a new index for this loop to avoid modifying ind itself, which is a constant
		success := true
		for i := range knownKeystream {

			loopInd = loopInd % 4 // circular indexing over the buffer, which gets updated when all bytes are consumed

			// if we used all the buffer's bytes, update it
			if loopInd == 0 && i != 0 {
				binary.BigEndian.PutUint32(keystreamBytes, gen.Rand())
			}

			// if there's a different byte, we can discard the seed
			if knownKeystream[i] != keystreamBytes[loopInd] {
				success = false
				break
			}

			loopInd++
		}

		if success {
			fmt.Println("Bruteforced key is", x)
			break
		}
	}
}

// MTCipher is a streaming cipher implementation with MT19937 as the keystream generator. Instead of carefully crafting a counter block such as in challenge
// 18, we'll directly use raw random numbers generated by the PRNG, by populating a 4 bytes buffer with each uint32.
func MTCipher(seed int, stream []byte) []byte {

	// 0. Create recipient for de/encryptions
	result := make([]byte, len(stream))

	// 1. Instantiate PRNG
	gen := mt19937.NewPRNG(seed)

	// 2. Start a loop to stream cipher.
	// n is the index for the current streaming byte
	keystreamBytes := make([]byte, 4) // bytes buffer for each uint32
	for n := range stream {

		// 2.1 Update keystream once buffer was consumed or when starting out
		r := n % 4
		if r == 0 {
			binary.BigEndian.PutUint32(keystreamBytes, gen.Rand())
		}

		// fmt.Printf(">> %d::%d\n", n, keystreamBytes[r])
		// 2.2 XOR / unXOR
		result[n] = stream[n] ^ keystreamBytes[r]
	}

	return result
}
